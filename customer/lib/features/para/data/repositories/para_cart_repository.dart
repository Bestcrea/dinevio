import 'package:customer/features/para/data/models/para_cart_item_model.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

/// Repository for cart operations
class ParaCartRepository {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  String _getCartPath(String uid) => 'users/$uid/para_cart/current';
  String _getCartItemsPath(String uid) => '$_getCartPath(uid)/items';

  /// Get current cart
  Future<ParaCartModel?> getCart(String uid) async {
    try {
      final doc = await _firestore.doc(_getCartPath(uid)).get();
      if (!doc.exists) return null;
      return ParaCartModel.fromDoc(doc);
    } catch (e) {
      throw Exception('Failed to get cart: $e');
    }
  }

  /// Get cart items
  Future<List<ParaCartItemModel>> getCartItems(String uid) async {
    try {
      final snapshot = await _firestore.collection(_getCartItemsPath(uid)).get();
      return snapshot.docs.map((doc) => ParaCartItemModel.fromDoc(doc)).toList();
    } catch (e) {
      throw Exception('Failed to get cart items: $e');
    }
  }

  /// Initialize or update cart summary
  Future<void> updateCartSummary({
    required String uid,
    required String shopId,
    required String shopName,
    required double subtotal,
    double deliveryFee = 15.0,
  }) async {
    try {
      final total = subtotal + deliveryFee;
      await _firestore.doc(_getCartPath(uid)).set({
        'shopId': shopId,
        'shopName': shopName,
        'currency': 'MAD',
        'subtotal': subtotal,
        'deliveryFee': deliveryFee,
        'total': total,
        'updatedAt': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));
    } catch (e) {
      throw Exception('Failed to update cart summary: $e');
    }
  }

  /// Add item to cart (or increment if exists)
  Future<void> addItem({
    required String uid,
    required String productId,
    required String title,
    required String imageUrl,
    required double unitPriceMad,
    required String shopId,
    required String shopName,
  }) async {
    try {
      // Check if cart exists and has different shop
      final existingCart = await getCart(uid);
      if (existingCart != null && existingCart.shopId != shopId) {
        throw Exception('CART_CONFLICT'); // Special error for UI to handle
      }

      // Check if item already exists
      final itemsSnapshot = await _firestore
          .collection(_getCartItemsPath(uid))
          .where('productId', isEqualTo: productId)
          .limit(1)
          .get();

      if (itemsSnapshot.docs.isNotEmpty) {
        // Increment quantity
        final existingDoc = itemsSnapshot.docs.first;
        final existingItem = ParaCartItemModel.fromDoc(existingDoc);
        final newQuantity = existingItem.quantity + 1;
        final newLineTotal = unitPriceMad * newQuantity;

        await existingDoc.reference.update({
          'quantity': newQuantity,
          'lineTotal': newLineTotal,
        });
      } else {
        // Add new item
        final newItem = ParaCartItemModel(
          id: '', // Will be generated by Firestore
          productId: productId,
          title: title,
          imageUrl: imageUrl,
          unitPriceMad: unitPriceMad,
          quantity: 1,
          lineTotal: unitPriceMad,
          createdAt: DateTime.now(),
        );
        await _firestore.collection(_getCartItemsPath(uid)).add(newItem.toJson());
      }

      // Recalculate totals
      await _recalculateTotals(uid, shopId, shopName);
    } catch (e) {
      if (e.toString().contains('CART_CONFLICT')) rethrow;
      throw Exception('Failed to add item: $e');
    }
  }

  /// Increase item quantity
  Future<void> increaseQuantity(String uid, String itemId, double unitPrice) async {
    try {
      final itemRef = _firestore.collection(_getCartItemsPath(uid)).doc(itemId);
      final itemDoc = await itemRef.get();
      if (!itemDoc.exists) throw Exception('Item not found');

      final currentQuantity = (itemDoc.data()?['quantity'] as num?)?.toInt() ?? 0;
      final newQuantity = currentQuantity + 1;
      final newLineTotal = unitPrice * newQuantity;

      await itemRef.update({
        'quantity': newQuantity,
        'lineTotal': newLineTotal,
      });

      final cart = await getCart(uid);
      if (cart != null) {
        await _recalculateTotals(uid, cart.shopId, cart.shopName);
      }
    } catch (e) {
      throw Exception('Failed to increase quantity: $e');
    }
  }

  /// Decrease item quantity (remove if hits 0)
  Future<void> decreaseQuantity(String uid, String itemId, double unitPrice) async {
    try {
      final itemRef = _firestore.collection(_getCartItemsPath(uid)).doc(itemId);
      final itemDoc = await itemRef.get();
      if (!itemDoc.exists) throw Exception('Item not found');

      final currentQuantity = (itemDoc.data()?['quantity'] as num?)?.toInt() ?? 0;
      if (currentQuantity <= 1) {
        // Remove item
        await itemRef.delete();
      } else {
        final newQuantity = currentQuantity - 1;
        final newLineTotal = unitPrice * newQuantity;
        await itemRef.update({
          'quantity': newQuantity,
          'lineTotal': newLineTotal,
        });
      }

      final cart = await getCart(uid);
      if (cart != null) {
        await _recalculateTotals(uid, cart.shopId, cart.shopName);
      }
    } catch (e) {
      throw Exception('Failed to decrease quantity: $e');
    }
  }

  /// Remove item from cart
  Future<void> removeItem(String uid, String itemId) async {
    try {
      await _firestore.collection(_getCartItemsPath(uid)).doc(itemId).delete();
      final cart = await getCart(uid);
      if (cart != null) {
        await _recalculateTotals(uid, cart.shopId, cart.shopName);
      }
    } catch (e) {
      throw Exception('Failed to remove item: $e');
    }
  }

  /// Clear entire cart
  Future<void> clearCart(String uid) async {
    try {
      final batch = _firestore.batch();
      
      // Delete all items
      final itemsSnapshot = await _firestore.collection(_getCartItemsPath(uid)).get();
      for (var doc in itemsSnapshot.docs) {
        batch.delete(doc.reference);
      }
      
      // Delete cart summary
      batch.delete(_firestore.doc(_getCartPath(uid)));
      
      await batch.commit();
    } catch (e) {
      throw Exception('Failed to clear cart: $e');
    }
  }

  /// Recalculate cart totals
  Future<void> _recalculateTotals(String uid, String shopId, String shopName) async {
    try {
      final items = await getCartItems(uid);
      final subtotal = items.fold<double>(0.0, (sum, item) => sum + item.lineTotal);
      await updateCartSummary(
        uid: uid,
        shopId: shopId,
        shopName: shopName,
        subtotal: subtotal,
      );
    } catch (e) {
      throw Exception('Failed to recalculate totals: $e');
    }
  }

  /// Get total item count
  Future<int> getItemCount(String uid) async {
    try {
      final items = await getCartItems(uid);
      return items.fold<int>(0, (sum, item) => sum + item.quantity);
    } catch (e) {
      return 0;
    }
  }
}

